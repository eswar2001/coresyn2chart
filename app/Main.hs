module Main where

import System.Directory ( doesDirectoryExist, listDirectory, createDirectoryIfMissing , removeFile)
import System.FilePath ( (</>) )
import Control.Monad (forM, unless, when)
import Data.List (isSuffixOf )
import Syn2Chart.Types ( LBind, Function(..),CaseExtract(..),generateHash)
import Data.Aeson ( encode, eitherDecodeStrict )
import Data.ByteString.Lazy (toStrict)
import Syn2Chart.Traversal ( translateCoreProgramToCFG )
import qualified Data.ByteString.Base64 as BS
import qualified Data.Map as Map
import qualified Data.ByteString as DBS
import Data.Text (unpack,Text,pack,unpack)
import Control.Exception ( catch, throwIO , try , SomeException)
import System.Directory.Internal.Prelude (isDoesNotExistError)
import qualified Data.HashMap.Strict as HM
import qualified Data.Text as T
import Control.Concurrent (threadDelay)
import Control.Concurrent.Async (async, wait)
import Data.Default (Default (..))
import Data.Bool (bool)
import Control.Concurrent.MVar
    ( putMVar, readMVar, takeMVar, newMVar, MVar )
import Options.Applicative
    ( (<**>),
      auto,
      fullDesc,
      header,
      help,
      info,
      long,
      metavar,
      option,
      progDesc,
      short,
      strOption,
      value,
      execParser,
      helper,
      Parser )
import Crypto.Hash
import Universum (decodeUtf8)
import Control.Exception.Base (evaluate)
import Control.DeepSeq (force)
import Database.Bolt
import qualified Data.HashSet as HashSet

getBase64FunctionName :: String -> String
getBase64FunctionName = unpack . decodeUtf8 . BS.encode . toStrict . encode

removeIfExists :: FilePath -> IO ()
removeIfExists fileName = removeFile fileName `catch` handleExists
  where handleExists e
          | isDoesNotExistError e = return ()
          | otherwise = throwIO e

data CoreSyn2Chart = CoreSyn2Chart
  { path      :: String
  , function      :: String
  , pattern :: String
  , clean :: Bool
  }
  deriving (Show)

cliOptions :: Parser CoreSyn2Chart
cliOptions = CoreSyn2Chart
      <$> strOption
            ( long "path"
              <> short 'p'
              <> metavar "STRING"
              <> value "/tmp/coresyn2chart/"
              <> help "path of plugin dump"
            )
      <*> strOption
          ( long "function"
              <> short 'f'
              <> metavar "STRING"
              <> value "all"
              <> help "which function to process"
          )
      <*> strOption
          ( long "pattern"
              <> short 'i'
              <> metavar "STRING"
              <> value ""
              <> help "filter functions based on infix pattern"
          )
      <*> option auto
          ( long "clean"
              <> short 'd'
              <> metavar "Bool"
              <> value True
              <> help "delete the existing dump"
          )

main :: IO ()
main = do
  opts <- execParser (info (cliOptions <**> helper) (fullDesc <> progDesc " Tool to parse coresyn2chart dumps " <> header "coresyn2chart - an exe to generate paths for a flow from the dump generated by the plugin" ))
  let prefixPath = path opts
      functionName = function opts
      shouldDeleteDump = clean opts
      functionFilterInfix = pattern opts

  files <- getDirectoryContentsRecursive prefixPath

  let jsonFiles = filter (".lbind.ast.show.json" `isSuffixOf`) files
  print ("found " <> show (Prelude.length jsonFiles) <> " files")

  createDirectoryIfMissing True prefixPath

  print ("loading the files from dump" :: String)
  binds <- forM jsonFiles (`processDumpFiles` prefixPath)

  let hmBinds = HM.fromList $ filter (not . shouldFilter) $ concat binds
  pipe <- connect $ def { user = "neo4j", password = "" , host = "localhost"  }
  case functionName of
    "all" -> do
      when shouldDeleteDump $ do
        removeIfExists (prefixPath <> "data.jsonL")
        removeIfExists (prefixPath <> "data-lbind.jsonL")
        removeIfExists (prefixPath <> "top-lvl-binds.json")
        removeIfExists (prefixPath <> "function-flows-cnt.txt")

      print ("created the top-lvl-binds for reference at: " <> prefixPath)
      DBS.writeFile (prefixPath <> "top-lvl-binds.json") (toStrict $ encode $ HM.keys hmBinds)

      print ("No specific function is passed so , generating for all " <> show (Prelude.length (HM.keys hmBinds)) <> " top-level-binds")
      mapM_ (\(name,functionData) -> do
        print ("processing function: " <> (unpack name))
        DBS.appendFile (prefixPath <> "data-lbind.jsonL") (toStrict (encode functionData) Prelude.<> "\n")
        pathsMvar <- newMVar 0
        relationsMvar <- newMVar (HashSet.empty)
        convertBindToEdgesList prefixPath functionData hmBinds pathsMvar pipe relationsMvar
        paths <- readMVar pathsMvar
        DBS.appendFile (prefixPath <> "function-flows-cnt.txt") ((toStrict $ encode $ "got " <> show paths <> " paths for the function: " <> (unpack name)) <> "\n")
        ) (filter (\(k,_) -> ((pack functionFilterInfix) `T.isInfixOf` k) && (not $ "cardFingerPrintV2" `T.isInfixOf` k)) $ HM.toList hmBinds)
    x ->
      case HM.lookup (pack x) hmBinds of
        Just bind -> do
          print ("processing function: " <> x)
          DBS.appendFile (prefixPath <> "data-lbind.jsonL") (toStrict (encode bind) Prelude.<> "\n")
          pathsMvar <- newMVar 0
          relationsMvar <- newMVar (HashSet.empty)
          convertBindToEdgesList prefixPath bind hmBinds pathsMvar pipe relationsMvar
          paths <- readMVar pathsMvar
          DBS.appendFile (prefixPath <> "function-flows-cnt.txt") ((toStrict $ encode $ "got " <> show paths <>  " paths for the function: " <> x) <> "\n")
        Nothing -> print ("function not found , can you pick from this file: " <> prefixPath <> " top-lvl-binds.json")
  where
    shouldFilter x =
      let n =  fst x
      in ("$_in$$" `T.isInfixOf` n || "$_sys$" `T.isInfixOf` n || "$$" `T.isInfixOf` n)

getDirectoryContentsRecursive :: FilePath -> IO [FilePath]
getDirectoryContentsRecursive dir = do
    names <- listDirectory dir
    paths <- forM names $ \name -> do
        let path = dir </> name
        isDirectory <- doesDirectoryExist path
        if isDirectory
            then getDirectoryContentsRecursive path
            else return [path]
    return (concat paths)

processDumpFiles :: String -> String -> IO [(Text,Function)]
processDumpFiles file _ = do
  content <- DBS.readFile file
  case eitherDecodeStrict content of
    Right (binds :: [LBind]) ->
      mapM (\functionData@(Function _name _type _ _ _) -> pure (_name,functionData)) (translateCoreProgramToCFG binds)
    Left err -> do
      print err
      print file
      pure []

type Edge = (Text,Bool,Text)
data NodeTypes = NFunction | NStartFunction | NEnd
  deriving (Eq)

instance Show NodeTypes where
  show (NFunction) = "Function"
  show (NStartFunction) = "StartFunction"
  show (NEnd) = "END"

checkForErrorFlows :: [Edge] -> Bool
checkForErrorFlows = any (\(edge,_,_) -> any (`T.isInfixOf` edge) errorFlow)
  where
    errorFlow :: [Text]
    errorFlow = ["throwException","handleClientError"]

shouldExpandThese :: Edge -> Bool
shouldExpandThese (name,_,_) = not $ any (\(_,func) -> func `T.isInfixOf` name) [("euler-hs" :: [Char],"forkFlow")]

functionsToFilterFromPath :: Edge -> Bool
functionsToFilterFromPath (_,True,_) = True
functionsToFilterFromPath (name,False,_) = any (`T.isInfixOf` name) ["$_sys$"]

tryWriteHelper :: FilePath -> DBS.ByteString -> Int -> Int -> IO ()
tryWriteHelper path content maxRetries currentRetry
  | currentRetry >= maxRetries = do
    putStrLn "Maximum retries reached, giving up."
    print content
  | otherwise = do
      res <- try $ DBS.appendFile path content
      case res of
        Right _ -> pure () --putStrLn "Write successful."
        Left (err :: SomeException) -> do
          putStrLn $ "Attempt " ++ show (currentRetry + 1) ++ " failed: " ++ show err
          threadDelay 10000
          tryWriteHelper path content maxRetries (currentRetry + 1)

hashToText :: (Foldable t, Show a) => t a -> Text
hashToText strs = pack $ show (hash (toStrict $ encode $ concatMap show strs) :: Digest  SHA3_256)

hashToTextText :: Text -> Text
hashToTextText strs = pack $ show (hash (toStrict $ encode $ strs) :: Digest  SHA3_256)

insertNode :: Pipe -> NodeTypes -> Edge -> Text -> IO ()
insertNode pipe typeOfNode (name,isCase,uniqueId) context = do
  let params = Map.fromList [ ("name", T name)
                , ("isCase", B isCase)
                , ("uniqueId", T uniqueId)
                , ("context", T context)
                ]
      cypher = "CREATE (n:"<> (pack $ show typeOfNode) <> " {name: $name, isCase: $isCase, uniqueId: $uniqueId, context: $context}) RETURN n"
  (res :: Either SomeException [Record]) <- try $ run pipe $ queryP cypher params
  -- either print (\x -> pure ()) res
  pure ()

createRelationship :: Pipe -> Bool -> Bool -> Edge -> Edge -> Maybe Text -> MVar (HashSet.HashSet Text) -> IO ()
createRelationship pipe isEnd isStart (pName,pIsCase,uniqueId1) (cName,cIsCase,uniqueId2) mRelation relationsMvar = do
  let params = Map.fromList [("pName", T pName) , ("pIsCase", B pIsCase) , ("uniqueId1", T uniqueId1), ("cName", T cName) , ("cIsCase", B cIsCase) , ("uniqueId2", T uniqueId2)]
      prop = "RELATED_TO {edge: " <> maybe "\'NO_MATCH\'" (pack . show) mRelation <> "}"
      cypher = "MATCH (a:" <> bool (pack $ show NFunction) (pack $ show NStartFunction) isStart <> " {name: $pName, isCase: $pIsCase, uniqueId: $uniqueId1}), (b:" <> bool (pack $ show NFunction) (pack $ show NEnd) isEnd <> " {name: $cName, isCase: $cIsCase, uniqueId: $uniqueId2}) \
              \WHERE NOT EXISTS((a)-[:" <> prop <> "]->(b)) \
              \CREATE (a)-[r:" <> prop <> "]->(b) \
              \RETURN r"
      cypherText = uniqueId1 <> prop <> uniqueId2
  l <- takeMVar relationsMvar
  case HashSet.member cypherText l of
    False -> do
      res <- run pipe $ queryP cypher params
      -- print cypherText
      putMVar relationsMvar $ HashSet.insert cypherText l
    True -> do
      -- print ("duplicate relation",cypherText)
      putMVar relationsMvar l
  pure ()

convertBindToEdgesList :: String -> Function -> HM.HashMap Text Function -> MVar Int -> Pipe -> MVar (HashSet.HashSet Text) -> IO ()
convertBindToEdgesList prefixPath (Function pName _ pIsCase pChildren _) hmBinds mvar pipe relationsMvar = do
  insertNode pipe NStartFunction (pName,pIsCase,pName) ""
  go "" HM.empty True [(pName,pIsCase,pName)] Nothing "" pChildren [] HashSet.empty
  where
    go :: Text -> HM.HashMap Text Text -> Bool -> [Edge] -> Maybe Text -> Text -> [Function] -> [Function] -> HashSet.HashSet Text -> IO ()
    go dump caseMemory isStart prev relation acc [] [] visitedHashSet =
      unless (checkForErrorFlows prev) $ do
        currentNodeHash <- evaluate $ force $ hashToTextText acc
        insertNode pipe NEnd ("END",False,currentNodeHash) acc
        createRelationship pipe True False (last prev) ("END",False,currentNodeHash) relation relationsMvar
        l <- takeMVar mvar
        print (l,hashToTextText dump)
        tryWriteHelper (prefixPath <> "data.jsonL") (toStrict $ encode prev Prelude.<> "\n") 100 0
        putMVar mvar (l + 1)
    go dump caseMemory isStart prev relation acc [] futureFunctions visitedHashSet = go dump caseMemory isStart prev relation acc futureFunctions [] visitedHashSet
    go dump caseMemory isStart prev relation acc currentNodes futureFunctions visitedHashSet = do
      mapM_ (\x -> do
          case x of
            (Function _name _type isCase childChildren srcSpan) -> do
              currentNodeHash <- evaluate $ force $ hashToText (show prev <> show [(_name,isCase,_name,relation)])
              if not (checkForErrorFlows [(_name,isCase,currentNodeHash)])
                then
                  if shouldExpandThese (_name,isCase,"")
                      then
                        case HM.lookup _name hmBinds of
                          Just (Function __name __type _isCase _childChildren _) -> do
                            if _name /= pName && (not $ HashSet.member _name visitedHashSet)
                              then go (dump <> "("<>"FUNCTION___" <> _name <> "__SRCSPAN" <> (pack $ show srcSpan) <>")") caseMemory isStart prev relation (acc <> (pack $ show (_name))) _childChildren (childChildren <> futureFunctions) (HashSet.insert _name visitedHashSet)
                              else do
                                go (dump <> "("<>"FUNCTION___" <> _name <> "__SRCSPAN" <> (pack $ show srcSpan) <>")") caseMemory isStart prev relation (acc <> (pack $ show (_name))) childChildren futureFunctions (visitedHashSet)
                          _ -> do
                            DBS.appendFile (prefixPath <> "data-lbind-rec.jsonL") (toStrict (encode $ _name <> ((pack $ show srcSpan))) Prelude.<> "\n")
                            go (dump <> "("<>"FUNCTION___" <> _name <> "__SRCSPAN" <> (pack $ show srcSpan) <>")") caseMemory isStart prev relation (acc <> (pack $ show (_name))) childChildren futureFunctions (visitedHashSet)
                      else go (dump <> "("<>"FUNCTION___" <> _name <> "__SRCSPAN" <> (pack $ show srcSpan) <>")") caseMemory isStart prev relation (acc <> (pack $ show (_name))) childChildren futureFunctions (visitedHashSet)
                else do
                  pure ()
            (CaseFunction _id caseExtract _name _type isCase childChildren _) -> do
              currentNodeHash <- evaluate $ force $ pack $ show _id
              insertNode pipe NFunction (_name,isCase,currentNodeHash) acc
              createRelationship pipe False isStart (last prev) (_name,isCase,currentNodeHash) relation relationsMvar
              mPrevRelation <- pure $ checkAndReturnIfInCaseMemory caseMemory caseExtract
              case mPrevRelation of
                Just prevRelation -> do
                  mapM_ (\(CaseRelation __name __type _isCase _childChildren _) -> do
                      currentPathHash <- evaluate $ force $ hashToTextText $ dump <> "CASE__" <> _name <> " -> __RELATION__ " <> __name <> " FOUND ,"
                      l <- takeMVar relationsMvar
                      if (prevRelation == __name && (not $ HashSet.member currentPathHash l))
                        then do
                          putMVar relationsMvar $ HashSet.insert currentPathHash l
                          go (dump <> "CASE__" <> _name <> " -> __RELATION__ " <> __name <> " FOUND ,") caseMemory False (prev <> [(_name,isCase,currentNodeHash)]) (Just (__name <> " :: " <> __type)) "" _childChildren futureFunctions (HashSet.insert currentPathHash visitedHashSet)
                        else putMVar relationsMvar l
                    ) childChildren
                Nothing ->
                  mapM_ (\(CaseRelation __name __type _isCase _childChildren _) -> do
                      currentPathHash <- evaluate $ force $ hashToTextText $ (dump <> "CASE__" <> _name <> " -> __RELATION__ " <> __name <> "," <> "adding **("<> (pack $ show (caseExtract,__name,__type)) <>")**")
                      l <- takeMVar relationsMvar
                      if (not $ HashSet.member currentPathHash l)
                        then do
                          putMVar relationsMvar $ HashSet.insert currentPathHash l
                          go (dump <> "CASE__" <> _name <> " -> __RELATION__ " <> __name <> "," <> "adding **("<> (pack $ show (caseExtract,__name,__type)) <>")**") (addToCaseMemory caseMemory caseExtract __name __type) False (prev <> [(_name,isCase,currentNodeHash)]) (Just (__name <> " :: " <> __type)) "" _childChildren futureFunctions ((HashSet.insert currentPathHash visitedHashSet))
                        else putMVar relationsMvar l
                    ) childChildren
        ) currentNodes

checkAndReturnIfInCaseMemory :: HM.HashMap Text Text -> Maybe CaseExtract -> Maybe Text
checkAndReturnIfInCaseMemory caseMemory (Just key) = HM.lookup (generateHash key) caseMemory
checkAndReturnIfInCaseMemory  _ _ = Nothing

addToCaseMemory :: HM.HashMap Text Text -> Maybe CaseExtract -> Text -> Text -> HM.HashMap Text Text
addToCaseMemory caseMemory (Just key) relationName relationType
  = HM.insert (generateHash key) (relationName) caseMemory
addToCaseMemory hm _ _ _ = hm